# 1.1 Java Language Basics
## Complete Learning Guide from Beginner to Advanced

---

## Level 1: Java Syntax Fundamentals

### Variables and Data Types
**Explanation (English + فارسی):**
Variables are containers that store data values in memory. Java is a statically-typed language, meaning you must declare the data type of a variable before using it. Java has two categories of data types: primitive types (int, double, boolean, etc.) and reference types (objects, arrays, strings).

متغیرها کانتینرهایی هستند که مقادیر داده را در حافظه ذخیره می‌کنند. جاوا یک زبان استاتیک-تایپ است، به این معنی که باید نوع داده متغیر را قبل از استفاده اعلام کنید. جاوا دو دسته نوع داده دارد: انواع اولیه (int, double, boolean و غیره) و انواع مرجع (اشیاء، آرایه‌ها، رشته‌ها).

**Example (Code):**
```java
// Primitive data types
int age = 25;                    // 32-bit integer
double salary = 50000.50;        // 64-bit floating point
boolean isActive = true;         // true or false
char grade = 'A';                // 16-bit Unicode character
byte smallNumber = 100;          // 8-bit integer
short mediumNumber = 32000;      // 16-bit integer
long bigNumber = 1234567890L;    // 64-bit integer
float decimal = 3.14f;           // 32-bit floating point

// Reference data types
String name = "John Doe";        // String object
int[] numbers = {1, 2, 3, 4, 5}; // Array of integers
```

**Pitfalls / Best Practices:**
- **Pitfall:** Forgetting to initialize variables before use
- **Pitfall:** Using `==` for string comparison instead of `.equals()`
- **Best Practice:** Use meaningful variable names (camelCase)
- **Best Practice:** Initialize variables at declaration when possible
- **Best Practice:** Use `final` for constants

---

### Operators and Expressions
**Explanation (English + فارسی):**
Operators are special symbols that perform specific operations on one, two, or three operands and return a result. Java supports arithmetic, relational, logical, bitwise, assignment, and conditional operators.

عملگرها نمادهای خاصی هستند که عملیات خاصی روی یک، دو یا سه عملوند انجام می‌دهند و نتیجه‌ای برمی‌گردانند. جاوا از عملگرهای حسابی، رابطه‌ای، منطقی، بیتی، انتساب و شرطی پشتیبانی می‌کند.

**Example (Code):**
```java
// Arithmetic operators
int a = 10, b = 3;
int sum = a + b;        // 13
int difference = a - b; // 7
int product = a * b;    // 30
int quotient = a / b;   // 3
int remainder = a % b;  // 1

// Relational operators
boolean isEqual = (a == b);        // false
boolean isNotEqual = (a != b);     // true
boolean isGreater = (a > b);       // true
boolean isLess = (a < b);          // false

// Logical operators
boolean x = true, y = false;
boolean andResult = x && y;        // false
boolean orResult = x || y;         // true
boolean notResult = !x;            // false

// Conditional operator (ternary)
int max = (a > b) ? a : b;         // 10
```

**Pitfalls / Best Practices:**
- **Pitfall:** Division by zero causes runtime exception
- **Pitfall:** Short-circuit evaluation in logical operators
- **Best Practice:** Use parentheses to clarify operator precedence
- **Best Practice:** Use meaningful variable names in expressions

---

## Level 2: Control Structures

### Conditional Statements
**Explanation (English + فارسی):**
Conditional statements allow your program to make decisions and execute different code blocks based on certain conditions. Java provides if-else statements and switch statements for this purpose.

دستورات شرطی به برنامه شما اجازه می‌دهند تصمیم‌گیری کنند و بلوک‌های کد مختلف را بر اساس شرایط خاص اجرا کنند. جاوا دستورات if-else و switch را برای این منظور ارائه می‌دهد.

**Example (Code):**
```java
// if-else statements
int score = 85;
String grade;

if (score >= 90) {
    grade = "A";
} else if (score >= 80) {
    grade = "B";
} else if (score >= 70) {
    grade = "C";
} else if (score >= 60) {
    grade = "D";
} else {
    grade = "F";
}

// Switch statement (Java 14+)
int dayOfWeek = 3;
String dayName = switch (dayOfWeek) {
    case 1 -> "Monday";
    case 2 -> "Tuesday";
    case 3 -> "Wednesday";
    case 4 -> "Thursday";
    case 5 -> "Friday";
    case 6 -> "Saturday";
    case 7 -> "Sunday";
    default -> "Invalid day";
};

// Traditional switch with break
char operation = '+';
switch (operation) {
    case '+':
        System.out.println("Addition");
        break;
    case '-':
        System.out.println("Subtraction");
        break;
    case '*':
        System.out.println("Multiplication");
        break;
    case '/':
        System.out.println("Division");
        break;
    default:
        System.out.println("Unknown operation");
}
```

**Pitfalls / Best Practices:**
- **Pitfall:** Forgetting break statements in traditional switch
- **Pitfall:** Using == for string comparison in switch
- **Best Practice:** Always include default case in switch
- **Best Practice:** Use switch expressions (Java 14+) for better readability
- **Best Practice:** Keep conditions simple and readable

---

### Loops and Iteration
**Explanation (English + فارسی):**
Loops allow you to execute a block of code repeatedly. Java provides three types of loops: for loop, while loop, and do-while loop. Each has its specific use cases and advantages.

حلقه‌ها به شما اجازه می‌دهند یک بلوک کد را به طور مکرر اجرا کنید. جاوا سه نوع حلقه ارائه می‌دهد: حلقه for، حلقه while و حلقه do-while. هر کدام موارد استفاده و مزایای خاص خود را دارند.

**Example (Code):**
```java
// For loop - when you know the number of iterations
for (int i = 0; i < 5; i++) {
    System.out.println("Iteration: " + i);
}

// Enhanced for loop (for-each) - for collections
int[] numbers = {1, 2, 3, 4, 5};
for (int number : numbers) {
    System.out.println("Number: " + number);
}

// While loop - when condition is checked before execution
int count = 0;
while (count < 3) {
    System.out.println("Count: " + count);
    count++;
}

// Do-while loop - when you need at least one execution
int userInput;
do {
    System.out.println("Enter a number (0 to exit): ");
    // userInput = scanner.nextInt(); // Assume scanner is available
    userInput = 1; // For example
} while (userInput != 0);

// Nested loops
for (int i = 1; i <= 3; i++) {
    for (int j = 1; j <= 3; j++) {
        System.out.println("i=" + i + ", j=" + j);
    }
}

// Loop control statements
for (int i = 0; i < 10; i++) {
    if (i == 3) {
        continue; // Skip this iteration
    }
    if (i == 7) {
        break; // Exit the loop
    }
    System.out.println("i: " + i);
}
```

**Pitfalls / Best Practices:**
- **Pitfall:** Infinite loops due to incorrect loop conditions
- **Pitfall:** Off-by-one errors in loop bounds
- **Best Practice:** Use enhanced for loop when possible
- **Best Practice:** Keep loop bodies small and focused
- **Best Practice:** Use meaningful loop variable names

---

## Level 3: Methods and Scope

### Method Declaration and Invocation
**Explanation (English + فارسی):**
Methods are blocks of code that perform specific tasks and can be called from other parts of the program. They help in code reusability, modularity, and organization. Methods can accept parameters and return values.

متدها بلوک‌هایی از کد هستند که وظایف خاصی انجام می‌دهند و می‌توانند از سایر قسمت‌های برنامه فراخوانی شوند. آن‌ها در قابلیت استفاده مجدد کد، مدولاریتی و سازماندهی کمک می‌کنند. متدها می‌توانند پارامتر دریافت کنند و مقادیر برگردانند.

**Example (Code):**
```java
public class Calculator {
    // Method with parameters and return value
    public static int add(int a, int b) {
        return a + b;
    }
    
    // Method with no parameters
    public static void printWelcome() {
        System.out.println("Welcome to Calculator!");
    }
    
    // Method with multiple parameters
    public static double calculateArea(double length, double width) {
        return length * width;
    }
    
    // Method with no return value (void)
    public static void printResult(int result) {
        System.out.println("Result: " + result);
    }
    
    // Method with different parameter types
    public static String formatNumber(double number, int decimalPlaces) {
        return String.format("%." + decimalPlaces + "f", number);
    }
    
    // Method overloading - same name, different parameters
    public static int multiply(int a, int b) {
        return a * b;
    }
    
    public static double multiply(double a, double b) {
        return a * b;
    }
    
    public static int multiply(int a, int b, int c) {
        return a * b * c;
    }
    
    public static void main(String[] args) {
        // Method invocation
        printWelcome();
        
        int sum = add(5, 3);
        printResult(sum);
        
        double area = calculateArea(10.5, 8.2);
        System.out.println("Area: " + formatNumber(area, 2));
        
        // Method overloading examples
        System.out.println("Int multiply: " + multiply(4, 5));
        System.out.println("Double multiply: " + multiply(4.5, 5.2));
        System.out.println("Triple multiply: " + multiply(2, 3, 4));
    }
}
```

**Pitfalls / Best Practices:**
- **Pitfall:** Method overloading based only on return type (not allowed)
- **Pitfall:** Forgetting to handle return values
- **Best Practice:** Use descriptive method names (verb-based)
- **Best Practice:** Keep methods small and focused (single responsibility)
- **Best Practice:** Use method overloading judiciously
- **Best Practice:** Document complex methods with JavaDoc

---

### Variable Scope and Lifetime
**Explanation (English + فارسی):**
Variable scope determines where a variable can be accessed in your program. Java has different scopes: local scope (within methods), instance scope (within objects), and class scope (static variables). Understanding scope is crucial for avoiding naming conflicts and memory management.

محدوده متغیر تعیین می‌کند که یک متغیر در کجای برنامه شما قابل دسترسی است. جاوا محدوده‌های مختلفی دارد: محدوده محلی (درون متدها)، محدوده نمونه (درون اشیاء) و محدوده کلاس (متغیرهای استاتیک). درک محدوده برای جلوگیری از تعارض نام‌گذاری و مدیریت حافظه ضروری است.

**Example (Code):**
```java
public class ScopeExample {
    // Class-level (static) variable
    private static int classVariable = 100;
    
    // Instance variable
    private int instanceVariable = 50;
    
    public void demonstrateScope() {
        // Local variable
        int localVariable = 25;
        
        System.out.println("Class variable: " + classVariable);
        System.out.println("Instance variable: " + instanceVariable);
        System.out.println("Local variable: " + localVariable);
        
        // Block scope
        {
            int blockVariable = 10;
            System.out.println("Block variable: " + blockVariable);
            // localVariable is still accessible here
            System.out.println("Local variable in block: " + localVariable);
        }
        
        // blockVariable is not accessible here
        // System.out.println(blockVariable); // Compilation error
        
        // Shadowing example
        int shadowedVariable = 30;
        {
            int shadowedVariable = 40; // Shadows the outer variable
            System.out.println("Inner shadowed: " + shadowedVariable); // 40
        }
        System.out.println("Outer shadowed: " + shadowedVariable); // 30
    }
    
    public static void staticMethod() {
        // Can access class variable
        System.out.println("Class variable in static method: " + classVariable);
        
        // Cannot access instance variable directly
        // System.out.println(instanceVariable); // Compilation error
        
        // Can access through object reference
        ScopeExample obj = new ScopeExample();
        System.out.println("Instance variable through object: " + obj.instanceVariable);
    }
    
    public static void main(String[] args) {
        ScopeExample example = new ScopeExample();
        example.demonstrateScope();
        staticMethod();
    }
}
```

**Pitfalls / Best Practices:**
- **Pitfall:** Variable shadowing can cause confusion
- **Pitfall:** Accessing variables outside their scope
- **Best Practice:** Use meaningful variable names to avoid shadowing
- **Best Practice:** Minimize variable scope when possible
- **Best Practice:** Initialize variables at the point of declaration
- **Best Practice:** Use final for variables that shouldn't change

---

## Level 4: Arrays and Strings

### Array Fundamentals
**Explanation (English + فارسی):**
Arrays are data structures that store multiple values of the same type in contiguous memory locations. They provide indexed access to elements and are fundamental to many algorithms and data processing tasks.

آرایه‌ها ساختارهای داده‌ای هستند که چندین مقدار از همان نوع را در مکان‌های حافظه مجاور ذخیره می‌کنند. آن‌ها دسترسی ایندکس‌دار به عناصر فراهم می‌کنند و برای بسیاری از الگوریتم‌ها و وظایف پردازش داده اساسی هستند.

**Example (Code):**
```java
public class ArrayExamples {
    public static void main(String[] args) {
        // Array declaration and initialization
        int[] numbers = {1, 2, 3, 4, 5};
        
        // Array declaration with size
        int[] scores = new int[5];
        scores[0] = 85;
        scores[1] = 92;
        scores[2] = 78;
        scores[3] = 96;
        scores[4] = 88;
        
        // Array length
        System.out.println("Array length: " + numbers.length);
        
        // Accessing array elements
        System.out.println("First element: " + numbers[0]);
        System.out.println("Last element: " + numbers[numbers.length - 1]);
        
        // Iterating through array
        System.out.println("All numbers:");
        for (int i = 0; i < numbers.length; i++) {
            System.out.println("Index " + i + ": " + numbers[i]);
        }
        
        // Enhanced for loop
        System.out.println("All scores:");
        for (int score : scores) {
            System.out.println("Score: " + score);
        }
        
        // Multi-dimensional arrays
        int[][] matrix = {
            {1, 2, 3},
            {4, 5, 6},
            {7, 8, 9}
        };
        
        System.out.println("Matrix elements:");
        for (int i = 0; i < matrix.length; i++) {
            for (int j = 0; j < matrix[i].length; j++) {
                System.out.print(matrix[i][j] + " ");
            }
            System.out.println();
        }
        
        // Array methods
        int[] original = {3, 1, 4, 1, 5};
        int[] copied = original.clone();
        System.out.println("Copied array: " + java.util.Arrays.toString(copied));
        
        // Array sorting
        java.util.Arrays.sort(original);
        System.out.println("Sorted array: " + java.util.Arrays.toString(original));
    }
}
```

**Pitfalls / Best Practices:**
- **Pitfall:** Array index out of bounds exception
- **Pitfall:** Forgetting that arrays are reference types
- **Best Practice:** Always check array bounds before access
- **Best Practice:** Use enhanced for loop when possible
- **Best Practice:** Initialize arrays with meaningful values
- **Best Practice:** Use Arrays utility class for common operations

---

### String Manipulation
**Explanation (English + فارسی):**
Strings in Java are objects that represent sequences of characters. They are immutable, meaning once created, their values cannot be changed. Java provides extensive methods for string manipulation, comparison, and formatting.

رشته‌ها در جاوا اشیائی هستند که دنباله‌ای از کاراکترها را نشان می‌دهند. آن‌ها غیرقابل تغییر هستند، به این معنی که پس از ایجاد، مقادیر آن‌ها قابل تغییر نیست. جاوا متدهای گسترده‌ای برای دستکاری، مقایسه و فرمت کردن رشته‌ها ارائه می‌دهد.

**Example (Code):**
```java
public class StringExamples {
    public static void main(String[] args) {
        // String creation
        String str1 = "Hello";
        String str2 = new String("World");
        String str3 = "Hello";
        
        // String comparison
        System.out.println("str1 == str3: " + (str1 == str3)); // true (string pool)
        System.out.println("str1 == str2: " + (str1 == str2)); // false (different objects)
        System.out.println("str1.equals(str2): " + str1.equals(str2)); // false
        System.out.println("str1.equals(str3): " + str1.equals(str3)); // true
        
        // String concatenation
        String greeting = str1 + " " + str2;
        System.out.println("Concatenation: " + greeting);
        
        // String methods
        String text = "  Hello World  ";
        System.out.println("Original: '" + text + "'");
        System.out.println("Length: " + text.length());
        System.out.println("Trimmed: '" + text.trim() + "'");
        System.out.println("Uppercase: " + text.toUpperCase());
        System.out.println("Lowercase: " + text.toLowerCase());
        
        // String searching
        String sentence = "Java is a powerful programming language";
        System.out.println("Contains 'Java': " + sentence.contains("Java"));
        System.out.println("Starts with 'Java': " + sentence.startsWith("Java"));
        System.out.println("Ends with 'language': " + sentence.endsWith("language"));
        System.out.println("Index of 'powerful': " + sentence.indexOf("powerful"));
        
        // String splitting
        String[] words = sentence.split(" ");
        System.out.println("Words:");
        for (String word : words) {
            System.out.println("- " + word);
        }
        
        // String formatting
        String name = "John";
        int age = 30;
        double salary = 50000.50;
        
        String formatted = String.format("Name: %s, Age: %d, Salary: $%.2f", name, age, salary);
        System.out.println("Formatted: " + formatted);
        
        // StringBuilder for efficient string building
        StringBuilder sb = new StringBuilder();
        sb.append("Hello");
        sb.append(" ");
        sb.append("World");
        sb.append("!");
        String result = sb.toString();
        System.out.println("StringBuilder result: " + result);
        
        // String immutability demonstration
        String original = "Hello";
        String modified = original.concat(" World");
        System.out.println("Original: " + original); // Still "Hello"
        System.out.println("Modified: " + modified); // "Hello World"
    }
}
```

**Pitfalls / Best Practices:**
- **Pitfall:** Using == for string comparison instead of .equals()
- **Pitfall:** Inefficient string concatenation in loops
- **Best Practice:** Use .equals() for string comparison
- **Best Practice:** Use StringBuilder for multiple string operations
- **Best Practice:** Handle null strings properly
- **Best Practice:** Use string formatting for complex output

---

## Level 5: Advanced Language Features

### Type Casting and Conversion
**Explanation (English + فارسی):**
Type casting is the process of converting a value from one data type to another. Java supports both implicit (automatic) and explicit (manual) type casting. Understanding when and how to cast types is essential for data manipulation and avoiding precision loss.

تبدیل نوع فرآیند تبدیل یک مقدار از یک نوع داده به نوع دیگر است. جاوا از تبدیل نوع ضمنی (خودکار) و صریح (دستی) پشتیبانی می‌کند. درک زمان و نحوه تبدیل انواع برای دستکاری داده و جلوگیری از از دست دادن دقت ضروری است.

**Example (Code):**
```java
public class TypeCastingExamples {
    public static void main(String[] args) {
        // Implicit casting (widening conversion)
        int intValue = 100;
        long longValue = intValue;        // int to long
        float floatValue = intValue;      // int to float
        double doubleValue = intValue;    // int to double
        
        System.out.println("Implicit casting:");
        System.out.println("int: " + intValue);
        System.out.println("long: " + longValue);
        System.out.println("float: " + floatValue);
        System.out.println("double: " + doubleValue);
        
        // Explicit casting (narrowing conversion)
        double preciseValue = 9.78;
        int truncatedValue = (int) preciseValue;  // double to int
        float roundedValue = (float) preciseValue; // double to float
        
        System.out.println("\nExplicit casting:");
        System.out.println("Original double: " + preciseValue);
        System.out.println("Truncated int: " + truncatedValue);
        System.out.println("Rounded float: " + roundedValue);
        
        // Character casting
        char character = 'A';
        int asciiValue = (int) character;
        char nextChar = (char) (character + 1);
        
        System.out.println("\nCharacter casting:");
        System.out.println("Character: " + character);
        System.out.println("ASCII value: " + asciiValue);
        System.out.println("Next character: " + nextChar);
        
        // String to number conversion
        String numberString = "123";
        int parsedInt = Integer.parseInt(numberString);
        double parsedDouble = Double.parseDouble("123.45");
        
        System.out.println("\nString to number:");
        System.out.println("Parsed int: " + parsedInt);
        System.out.println("Parsed double: " + parsedDouble);
        
        // Number to string conversion
        int number = 456;
        String stringFromInt = String.valueOf(number);
        String stringFromInt2 = Integer.toString(number);
        
        System.out.println("\nNumber to string:");
        System.out.println("String from int: " + stringFromInt);
        System.out.println("String from int (method 2): " + stringFromInt2);
        
        // Object casting (polymorphism)
        Object obj = "Hello World";
        String str = (String) obj;  // Safe casting
        System.out.println("\nObject casting:");
        System.out.println("Casted string: " + str);
        
        // instanceof check before casting
        if (obj instanceof String) {
            String safeStr = (String) obj;
            System.out.println("Safe casting: " + safeStr);
        }
    }
}
```

**Pitfalls / Best Practices:**
- **Pitfall:** Data loss in narrowing conversions
- **Pitfall:** ClassCastException when casting incompatible types
- **Best Practice:** Always check instanceof before object casting
- **Best Practice:** Be aware of precision loss in floating-point conversions
- **Best Practice:** Use wrapper classes for string-to-number conversion
- **Best Practice:** Handle NumberFormatException for parsing

---

### Input/Output Basics
**Explanation (English + فارسی):**
Input/Output (I/O) operations allow programs to interact with external data sources like files, user input, and network streams. Java provides various classes in the java.io package for handling different types of I/O operations.

عملیات ورودی/خروجی (I/O) به برنامه‌ها اجازه می‌دهند با منابع داده خارجی مانند فایل‌ها، ورودی کاربر و جریان‌های شبکه تعامل کنند. جاوا کلاس‌های مختلفی در بسته java.io برای مدیریت انواع مختلف عملیات I/O ارائه می‌دهد.

**Example (Code):**
```java
import java.io.*;
import java.util.Scanner;

public class IOExamples {
    public static void main(String[] args) {
        // Console input/output
        Scanner scanner = new Scanner(System.in);
        
        System.out.print("Enter your name: ");
        String name = scanner.nextLine();
        
        System.out.print("Enter your age: ");
        int age = scanner.nextInt();
        
        System.out.println("Hello " + name + ", you are " + age + " years old.");
        
        // File writing
        try {
            FileWriter writer = new FileWriter("output.txt");
            writer.write("Hello, World!\n");
            writer.write("This is a test file.\n");
            writer.write("Name: " + name + "\n");
            writer.write("Age: " + age + "\n");
            writer.close();
            System.out.println("Data written to file successfully.");
        } catch (IOException e) {
            System.out.println("Error writing to file: " + e.getMessage());
        }
        
        // File reading
        try {
            FileReader reader = new FileReader("output.txt");
            BufferedReader bufferedReader = new BufferedReader(reader);
            
            String line;
            System.out.println("\nFile contents:");
            while ((line = bufferedReader.readLine()) != null) {
                System.out.println(line);
            }
            bufferedReader.close();
        } catch (IOException e) {
            System.out.println("Error reading file: " + e.getMessage());
        }
        
        // Try-with-resources (automatic resource management)
        try (FileWriter writer = new FileWriter("auto-close.txt");
             PrintWriter printWriter = new PrintWriter(writer)) {
            
            printWriter.println("This file will be automatically closed.");
            printWriter.printf("Current time: %s%n", java.time.LocalDateTime.now());
            printWriter.println("No need to manually close resources.");
            
        } catch (IOException e) {
            System.out.println("Error: " + e.getMessage());
        }
        
        scanner.close();
    }
}
```

**Pitfalls / Best Practices:**
- **Pitfall:** Forgetting to close file resources (memory leaks)
- **Pitfall:** Not handling IOException properly
- **Best Practice:** Use try-with-resources for automatic resource management
- **Best Practice:** Always handle exceptions in I/O operations
- **Best Practice:** Use appropriate I/O classes for your needs
- **Best Practice:** Buffer I/O operations for better performance

---

## Level 6: Memory and Performance Considerations

### Memory Management Basics
**Explanation (English + فارسی):**
Java uses automatic memory management through garbage collection, but understanding how memory works helps write more efficient programs. The JVM manages memory in different areas: heap, stack, method area, and native method stacks.

جاوا از مدیریت حافظه خودکار از طریق جمع‌آوری زباله استفاده می‌کند، اما درک نحوه کار حافظه به نوشتن برنامه‌های کارآمدتر کمک می‌کند. JVM حافظه را در مناطق مختلف مدیریت می‌کند: heap، stack، ناحیه متد و پشته‌های متد بومی.

**Example (Code):**
```java
public class MemoryManagementExample {
    private static int staticVariable = 100; // Stored in method area
    private int instanceVariable = 50;       // Stored in heap
    
    public void demonstrateMemory() {
        // Local variables stored in stack
        int localVar1 = 10;
        int localVar2 = 20;
        
        // Object creation - stored in heap
        String str = new String("Hello World");
        int[] array = new int[1000];
        
        // Method calls create stack frames
        int result = calculateSum(localVar1, localVar2);
        
        System.out.println("Static variable: " + staticVariable);
        System.out.println("Instance variable: " + instanceVariable);
        System.out.println("Local variables: " + localVar1 + ", " + localVar2);
        System.out.println("String object: " + str);
        System.out.println("Array length: " + array.length);
        System.out.println("Calculation result: " + result);
        
        // Objects become eligible for garbage collection when out of scope
    }
    
    private int calculateSum(int a, int b) {
        // Parameters and local variables stored in stack
        int sum = a + b;
        return sum;
    }
    
    public static void main(String[] args) {
        MemoryManagementExample example = new MemoryManagementExample();
        example.demonstrateMemory();
        
        // Suggest garbage collection (not guaranteed)
        System.gc();
        
        // Memory information
        Runtime runtime = Runtime.getRuntime();
        long totalMemory = runtime.totalMemory();
        long freeMemory = runtime.freeMemory();
        long usedMemory = totalMemory - freeMemory;
        
        System.out.println("\nMemory Information:");
        System.out.println("Total memory: " + totalMemory / 1024 / 1024 + " MB");
        System.out.println("Free memory: " + freeMemory / 1024 / 1024 + " MB");
        System.out.println("Used memory: " + usedMemory / 1024 / 1024 + " MB");
    }
}
```

**Pitfalls / Best Practices:**
- **Pitfall:** Creating unnecessary objects in loops
- **Pitfall:** Holding references to objects longer than needed
- **Best Practice:** Reuse objects when possible
- **Best Practice:** Use primitive types instead of wrapper classes when possible
- **Best Practice:** Be mindful of memory usage in large applications
- **Best Practice:** Use profiling tools to identify memory issues

---

### Performance Optimization Techniques
**Explanation (English + فارسی):**
Performance optimization involves writing code that executes faster and uses resources more efficiently. This includes choosing appropriate data structures, avoiding common performance pitfalls, and understanding JVM optimizations.

بهینه‌سازی عملکرد شامل نوشتن کدی است که سریع‌تر اجرا می‌شود و از منابع به طور کارآمدتری استفاده می‌کند. این شامل انتخاب ساختارهای داده مناسب، اجتناب از تله‌های عملکرد رایج و درک بهینه‌سازی‌های JVM است.

**Example (Code):**
```java
import java.util.*;

public class PerformanceOptimization {
    
    // Inefficient string concatenation in loop
    public static String inefficientStringConcatenation(List<String> words) {
        String result = "";
        for (String word : words) {
            result += word + " "; // Creates new String object each time
        }
        return result;
    }
    
    // Efficient string concatenation using StringBuilder
    public static String efficientStringConcatenation(List<String> words) {
        StringBuilder result = new StringBuilder();
        for (String word : words) {
            result.append(word).append(" ");
        }
        return result.toString();
    }
    
    // Inefficient collection operations
    public static List<String> inefficientListOperations() {
        List<String> list = new ArrayList<>();
        for (int i = 0; i < 1000; i++) {
            list.add(0, "Item " + i); // O(n) operation each time
        }
        return list;
    }
    
    // Efficient collection operations
    public static List<String> efficientListOperations() {
        List<String> list = new ArrayList<>();
        for (int i = 0; i < 1000; i++) {
            list.add("Item " + i); // O(1) operation
        }
        return list;
    }
    
    // Caching example
    private static Map<Integer, Long> fibonacciCache = new HashMap<>();
    
    public static long fibonacci(int n) {
        if (n <= 1) return n;
        
        // Check cache first
        if (fibonacciCache.containsKey(n)) {
            return fibonacciCache.get(n);
        }
        
        // Calculate and cache result
        long result = fibonacci(n - 1) + fibonacci(n - 2);
        fibonacciCache.put(n, result);
        return result;
    }
    
    // Lazy initialization
    private static volatile PerformanceOptimization instance;
    
    public static PerformanceOptimization getInstance() {
        if (instance == null) {
            synchronized (PerformanceOptimization.class) {
                if (instance == null) {
                    instance = new PerformanceOptimization();
                }
            }
        }
        return instance;
    }
    
    public static void main(String[] args) {
        // Performance comparison
        List<String> words = Arrays.asList("Hello", "World", "Java", "Performance");
        
        long startTime, endTime;
        
        // Test string concatenation
        startTime = System.nanoTime();
        String result1 = inefficientStringConcatenation(words);
        endTime = System.nanoTime();
        System.out.println("Inefficient concatenation time: " + (endTime - startTime) + " ns");
        
        startTime = System.nanoTime();
        String result2 = efficientStringConcatenation(words);
        endTime = System.nanoTime();
        System.out.println("Efficient concatenation time: " + (endTime - startTime) + " ns");
        
        // Test caching
        startTime = System.nanoTime();
        long fib1 = fibonacci(40);
        endTime = System.nanoTime();
        System.out.println("Fibonacci(40) with caching: " + fib1 + " in " + (endTime - startTime) + " ns");
        
        // Test caching again (should be faster)
        startTime = System.nanoTime();
        long fib2 = fibonacci(40);
        endTime = System.nanoTime();
        System.out.println("Fibonacci(40) from cache: " + fib2 + " in " + (endTime - startTime) + " ns");
    }
}
```

**Pitfalls / Best Practices:**
- **Pitfall:** String concatenation in loops
- **Pitfall:** Using wrong data structures for the task
- **Pitfall:** Premature optimization
- **Best Practice:** Profile before optimizing
- **Best Practice:** Use appropriate data structures
- **Best Practice:** Implement caching for expensive operations
- **Best Practice:** Consider memory vs. time trade-offs

---

## Summary and Next Steps

### Key Takeaways
1. **Java Syntax**: Master variables, operators, and basic language constructs
2. **Control Flow**: Understand conditionals and loops for program logic
3. **Methods**: Learn to create reusable, well-structured code
4. **Data Structures**: Work with arrays and strings effectively
5. **Type System**: Handle type casting and conversions properly
6. **I/O Operations**: Interact with external data sources
7. **Memory Management**: Write memory-efficient code
8. **Performance**: Optimize code for better execution

### Common Interview Questions
1. What's the difference between `==` and `.equals()` for strings?
2. Explain the difference between primitive and reference types
3. What happens when you divide by zero in Java?
4. How do you handle null pointer exceptions?
5. What's the difference between `String`, `StringBuilder`, and `StringBuffer`?

### Next Learning Path
- **1.2 Object-Oriented Programming Principles**: Classes, objects, inheritance, polymorphism
- **1.3 Java Collections Framework**: Lists, sets, maps, and their implementations
- **1.4 Exception Handling**: Try-catch blocks, custom exceptions, best practices

### Practice Exercises
1. Create a calculator program with methods for basic operations
2. Write a program to find the largest number in an array
3. Implement a simple text file reader and writer
4. Create a program that counts word frequency in a text
5. Build a simple student grade management system

---

*This guide provides a solid foundation in Java language basics. Continue practicing these concepts and move on to object-oriented programming principles for the next level of Java mastery.*